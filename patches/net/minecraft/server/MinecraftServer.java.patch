--- net/minecraft/server/MinecraftServer.java
+++ net/minecraft/server/MinecraftServer.java
@@ -53,127 +53,200 @@
 import net.minecraft.src.WorldType;
 
 public abstract class MinecraftServer implements ICommandSender, Runnable, IPlayerUsage {
-	private static MinecraftServer l;
+
+	/** Instance of Minecraft Server. */
+	private static MinecraftServer mcServer;
 	private final ISaveFormat anvilConverterForAnvilFile;
-	private final PlayerUsageSnooper usageSnooper = new PlayerUsageSnooper("server", this, getCurrentTimeMillis());
-	private final File o;
-	private final List p = new ArrayList();
+
+	/** The PlayerUsageSnooper instance. */
+	private final PlayerUsageSnooper usageSnooper = new PlayerUsageSnooper("server", this, getSystemTimeMillis());
+	private final File anvilFile;
+
+	/**
+	 * Collection of objects to update every tick. Type: List<IUpdatePlayerListBox>
+	 */
+	private final List tickables = new ArrayList();
 	private final ICommandManager commandManager;
 	public final Profiler theProfiler = new Profiler();
-	private String r;
+
+	/** The server's hostname. */
+	private String hostname;
+
+	/** The server's port. */
 	private int serverPort = -1;
+
+	/** The server world instances. */
 	public WorldServer[] worldServers;
+
+	/** The ServerConfigurationManager instance. */
 	private ServerConfigurationManager serverConfigManager;
+
+	/**
+	 * Indicates whether the server is running or not. Set to false to initiate a shutdown.
+	 */
 	private boolean serverRunning = true;
+
+	/** Indicates to other classes that the server is safely stopped. */
 	private boolean serverStopped;
+
+	/** Incremented every tick. */
 	private int tickCounter;
-	protected Proxy c = Proxy.NO_PROXY;
-	public String d;
+	protected Proxy serverProxy;
+
+	/**
+	 * The task the server is currently working on(and will output on outputPercentRemaining).
+	 */
+	public String currentTask;
+
+	/** The percentage of the current task finished so far. */
 	public int percentDone;
+
+	/** True if the server is in online mode. */
 	private boolean onlineMode;
+
+	/** True if the server has animals turned on. */
 	private boolean canSpawnAnimals;
 	private boolean canSpawnNPCs;
+
+	/** Indicates whether PvP is active on the server or not. */
 	private boolean pvpEnabled;
+
+	/** Determines if flight is allowed or not. */
 	private boolean allowFlight;
-	private String C;
+
+	/** The server MOTD string. */
+	private String motd;
+
+	/** Maximum build height. */
 	private int buildLimit;
-	private int field_143008_E = 0;
+	private int field_143008_E;
 	private long lastSentPacketID;
 	private long lastSentPacketSize;
 	private long lastReceivedID;
 	private long lastReceivedSize;
-	public final long[] sentPacketCountArray = new long[100];
-	public final long[] sentPacketSizeArray = new long[100];
-	public final long[] receivedPacketCountArray = new long[100];
-	public final long[] receivedPacketSizeArray = new long[100];
-	public final long[] tickTimeArray = new long[100];
+	public final long[] sentPacketCountArray;
+	public final long[] sentPacketSizeArray;
+	public final long[] receivedPacketCountArray;
+	public final long[] receivedPacketSizeArray;
+	public final long[] tickTimeArray;
+
+	/** Stats are [dimension][tick%100] system.nanoTime is stored. */
 	public long[][] timeOfLastDimensionTick;
-	private KeyPair J;
-	private String K;
-	private String L;
-	private String M;
+	private KeyPair serverKeyPair;
+
+	/** Username of the server owner (for integrated servers) */
+	private String serverOwner;
+	private String folderName;
+	private String worldName;
 	private boolean isDemo;
 	private boolean enableBonusChest;
+
+	/**
+	 * If true, there is no need to save chunks or stop the server, because that is already being done.
+	 */
 	private boolean worldIsBeingDeleted;
-	private String Q = "";
+	private String texturePack;
 	private boolean serverIsRunning;
+
+	/**
+	 * Set when warned for "Can't keep up", which triggers again after 15 seconds.
+	 */
 	private long timeOfLastWarning;
-	private String T;
+	private String userMessage;
 	private boolean startProfiling;
 	private boolean isGamemodeForced;
 
-	public MinecraftServer(File var1) {
-		l = this;
-		this.o = var1;
+	public MinecraftServer(File par1File) {
+		this.serverProxy = Proxy.NO_PROXY;
+		this.field_143008_E = 0;
+		this.sentPacketCountArray = new long[100];
+		this.sentPacketSizeArray = new long[100];
+		this.receivedPacketCountArray = new long[100];
+		this.receivedPacketSizeArray = new long[100];
+		this.tickTimeArray = new long[100];
+		this.texturePack = "";
+		mcServer = this;
+		this.anvilFile = par1File;
 		this.commandManager = new ServerCommandManager();
-		this.anvilConverterForAnvilFile = new AnvilSaveConverter(var1);
+		this.anvilConverterForAnvilFile = new AnvilSaveConverter(par1File);
 		this.registerDispenseBehaviors();
 	}
 
+	/**
+	 * Register all dispense behaviors.
+	 */
 	private void registerDispenseBehaviors() {
 		DispenserBehaviors.registerDispenserBehaviours();
 	}
 
+	/**
+	 * Initialises the server and starts it.
+	 */
 	protected abstract boolean startServer() throws IOException;
 
-	protected void convertMapIfNeeded(String var1) {
-		if(this.getActiveAnvilConverter().isOldMapFormat(var1)) {
+	protected void convertMapIfNeeded(String par1Str) {
+		if (this.getActiveAnvilConverter().isOldMapFormat(par1Str)) {
 			this.getLogAgent().logInfo("Converting map!");
 			this.setUserMessage("menu.convertingLevel");
-			this.getActiveAnvilConverter().convertMapFormat(var1, new ConvertingProgressUpdate(this));
+			this.getActiveAnvilConverter().convertMapFormat(par1Str, new ConvertingProgressUpdate(this));
 		}
-
 	}
 
-	protected synchronized void setUserMessage(String var1) {
-		this.T = var1;
+	/**
+	 * Typically "menu.convertingLevel", "menu.loadingLevel" or others.
+	 */
+	protected synchronized void setUserMessage(String par1Str) {
+		this.userMessage = par1Str;
 	}
 
 	public synchronized String getUserMessage() {
-		return this.T;
+		return this.userMessage;
 	}
 
-	protected void loadAllWorlds(String var1, String var2, long var3, WorldType var5, String var6) {
-		this.convertMapIfNeeded(var1);
+	protected void loadAllWorlds(String par1Str, String par2Str, long par3, WorldType par5WorldType, String par6Str) {
+		this.convertMapIfNeeded(par1Str);
 		this.setUserMessage("menu.loadingLevel");
 		this.worldServers = new WorldServer[3];
 		this.timeOfLastDimensionTick = new long[this.worldServers.length][100];
-		ISaveHandler var7 = this.anvilConverterForAnvilFile.getSaveLoader(var1, true);
+		ISaveHandler var7 = this.anvilConverterForAnvilFile.getSaveLoader(par1Str, true);
 		WorldInfo var9 = var7.loadWorldInfo();
 		WorldSettings var8;
-		if(var9 == null) {
-			var8 = new WorldSettings(var3, this.getGameType(), this.canStructuresSpawn(), this.isHardcore(), var5);
-			var8.func_82750_a(var6);
+
+		if (var9 == null) {
+			var8 = new WorldSettings(par3, this.getGameType(), this.canStructuresSpawn(), this.isHardcore(), par5WorldType);
+			var8.func_82750_a(par6Str);
 		} else {
 			var8 = new WorldSettings(var9);
 		}
 
-		if(this.enableBonusChest) {
+		if (this.enableBonusChest) {
 			var8.enableBonusChest();
 		}
 
-		for(int var10 = 0; var10 < this.worldServers.length; ++var10) {
+		for (int var10 = 0; var10 < this.worldServers.length; ++var10) {
 			byte var11 = 0;
-			if(var10 == 1) {
+
+			if (var10 == 1) {
 				var11 = -1;
 			}
 
-			if(var10 == 2) {
+			if (var10 == 2) {
 				var11 = 1;
 			}
 
-			if(var10 == 0) {
-				if(this.isDemo()) {
-					this.worldServers[var10] = new DemoWorldServer(this, var7, var2, var11, this.theProfiler, this.getLogAgent());
+			if (var10 == 0) {
+				if (this.isDemo()) {
+					this.worldServers[var10] = new DemoWorldServer(this, var7, par2Str, var11, this.theProfiler, this.getLogAgent());
 				} else {
-					this.worldServers[var10] = new WorldServer(this, var7, var2, var11, var8, this.theProfiler, this.getLogAgent());
+					this.worldServers[var10] = new WorldServer(this, var7, par2Str, var11, var8, this.theProfiler, this.getLogAgent());
 				}
 			} else {
-				this.worldServers[var10] = new WorldServerMulti(this, var7, var2, var11, var8, this.worldServers[0], this.theProfiler, this.getLogAgent());
+				this.worldServers[var10] = new WorldServerMulti(this, var7, par2Str, var11, var8, this.worldServers[0], this.theProfiler, this.getLogAgent());
 			}
 
 			this.worldServers[var10].addWorldAccess(new WorldManager(this, this.worldServers[var10]));
-			if(!this.isSinglePlayer()) {
+
+			if (!this.isSinglePlayer()) {
 				this.worldServers[var10].getWorldInfo().setGameType(this.getGameType());
 			}
 
@@ -195,12 +268,13 @@
 		this.getLogAgent().logInfo("Preparing start region for level " + var6);
 		WorldServer var7 = this.worldServers[var6];
 		ChunkCoordinates var8 = var7.getSpawnPoint();
-		long var9 = getCurrentTimeMillis();
-
-		for(int var11 = -192; var11 <= 192 && this.isServerRunning(); var11 += 16) {
-			for(int var12 = -192; var12 <= 192 && this.isServerRunning(); var12 += 16) {
-				long var13 = getCurrentTimeMillis();
-				if(var13 - var9 > 1000L) {
+		long var9 = getSystemTimeMillis();
+
+		for (int var11 = -192; var11 <= 192 && this.isServerRunning(); var11 += 16) {
+			for (int var12 = -192; var12 <= 192 && this.isServerRunning(); var12 += 16) {
+				long var13 = getSystemTimeMillis();
+
+				if (var13 - var9 > 1000L) {
 					this.outputPercentRemaining("Preparing spawn area", var5 * 100 / 625);
 					var9 = var13;
 				}
@@ -217,32 +291,48 @@
 
 	public abstract EnumGameType getGameType();
 
+	/**
+	 * Defaults to "1" (Easy) for the dedicated server, defaults to "2" (Normal) on the client.
+	 */
 	public abstract int getDifficulty();
 
+	/**
+	 * Defaults to false.
+	 */
 	public abstract boolean isHardcore();
 
 	public abstract int func_110455_j();
 
-	protected void outputPercentRemaining(String var1, int var2) {
-		this.d = var1;
-		this.percentDone = var2;
-		this.getLogAgent().logInfo(var1 + ": " + var2 + "%");
+	/**
+	 * Used to display a percent remaining given text and the percentage.
+	 */
+	protected void outputPercentRemaining(String par1Str, int par2) {
+		this.currentTask = par1Str;
+		this.percentDone = par2;
+		this.getLogAgent().logInfo(par1Str + ": " + par2 + "%");
 	}
 
+	/**
+	 * Set current task to null and set its percentage to 0.
+	 */
 	protected void clearCurrentTask() {
-		this.d = null;
+		this.currentTask = null;
 		this.percentDone = 0;
 	}
 
-	protected void saveAllWorlds(boolean var1) {
-		if(!this.worldIsBeingDeleted) {
+	/**
+	 * par1 indicates if a log message should be output.
+	 */
+	protected void saveAllWorlds(boolean par1) {
+		if (!this.worldIsBeingDeleted) {
 			WorldServer[] var2 = this.worldServers;
 			int var3 = var2.length;
 
-			for(int var4 = 0; var4 < var3; ++var4) {
+			for (int var4 = 0; var4 < var3; ++var4) {
 				WorldServer var5 = var2[var4];
-				if(var5 != null) {
-					if(!var1) {
+
+				if (var5 != null) {
+					if (!par1) {
 						this.getLogAgent().logInfo("Saving chunks for level \'" + var5.getWorldInfo().getWorldName() + "\'/" + var5.provider.getDimensionName());
 					}
 
@@ -253,18 +343,21 @@
 					}
 				}
 			}
-
 		}
 	}
 
+	/**
+	 * Saves all necessary data as preparation for stopping the server.
+	 */
 	public void stopServer() {
-		if(!this.worldIsBeingDeleted) {
+		if (!this.worldIsBeingDeleted) {
 			this.getLogAgent().logInfo("Stopping server");
-			if(this.getNetworkThread() != null) {
+
+			if (this.getNetworkThread() != null) {
 				this.getNetworkThread().stopListening();
 			}
 
-			if(this.serverConfigManager != null) {
+			if (this.serverConfigManager != null) {
 				this.getLogAgent().logInfo("Saving players");
 				this.serverConfigManager.saveAllPlayerData();
 				this.serverConfigManager.removeAllPlayers();
@@ -273,60 +366,67 @@
 			this.getLogAgent().logInfo("Saving worlds");
 			this.saveAllWorlds(false);
 
-			for(int var1 = 0; var1 < this.worldServers.length; ++var1) {
+			for (int var1 = 0; var1 < this.worldServers.length; ++var1) {
 				WorldServer var2 = this.worldServers[var1];
 				var2.flush();
 			}
 
-			if(this.usageSnooper != null && this.usageSnooper.isSnooperRunning()) {
+			if (this.usageSnooper != null && this.usageSnooper.isSnooperRunning()) {
 				this.usageSnooper.stopSnooper();
 			}
-
 		}
 	}
 
+	/**
+	 * "getHostname" is already taken, but both return the hostname.
+	 */
 	public String getServerHostname() {
-		return this.r;
+		return this.hostname;
 	}
 
-	public void setHostname(String var1) {
-		this.r = var1;
+	public void setHostname(String par1Str) {
+		this.hostname = par1Str;
 	}
 
 	public boolean isServerRunning() {
 		return this.serverRunning;
 	}
 
+	/**
+	 * Sets the serverRunning variable to false, in order to get the server to shut down.
+	 */
 	public void initiateShutdown() {
 		this.serverRunning = false;
 	}
 
 	public void run() {
 		try {
-			if(this.startServer()) {
-				long var1 = getCurrentTimeMillis();
+			if (this.startServer()) {
+				long var1 = getSystemTimeMillis();
 
-				for(long var50 = 0L; this.serverRunning; this.serverIsRunning = true) {
-					long var5 = getCurrentTimeMillis();
+				for (long var50 = 0L; this.serverRunning; this.serverIsRunning = true) {
+					long var5 = getSystemTimeMillis();
 					long var7 = var5 - var1;
-					if(var7 > 2000L && var1 - this.timeOfLastWarning >= 15000L) {
+
+					if (var7 > 2000L && var1 - this.timeOfLastWarning >= 15000L) {
 						this.getLogAgent().logWarning("Can\'t keep up! Did the system time change, or is the server overloaded?");
 						var7 = 2000L;
 						this.timeOfLastWarning = var1;
 					}
 
-					if(var7 < 0L) {
+					if (var7 < 0L) {
 						this.getLogAgent().logWarning("Time ran backwards! Did the system time change?");
 						var7 = 0L;
 					}
 
 					var50 += var7;
 					var1 = var5;
-					if(this.worldServers[0].areAllPlayersAsleep()) {
+
+					if (this.worldServers[0].areAllPlayersAsleep()) {
 						this.tick();
 						var50 = 0L;
 					} else {
-						while(var50 > 50L) {
+						while (var50 > 50L) {
 							var50 -= 50L;
 							this.tick();
 						}
@@ -341,14 +441,16 @@
 			var48.printStackTrace();
 			this.getLogAgent().logSevereException("Encountered an unexpected exception " + var48.getClass().getSimpleName(), var48);
 			CrashReport var2 = null;
-			if(var48 instanceof ReportedException) {
+
+			if (var48 instanceof ReportedException) {
 				var2 = this.addServerInfoToCrashReport(((ReportedException)var48).getCrashReport());
 			} else {
 				var2 = this.addServerInfoToCrashReport(new CrashReport("Exception in server tick loop", var48));
 			}
 
 			File var3 = new File(new File(this.getDataDirectory(), "crash-reports"), "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-server.txt");
-			if(var2.saveToFile(var3, this.getLogAgent())) {
+
+			if (var2.saveToFile(var3, this.getLogAgent())) {
 				this.getLogAgent().logSevere("This crash report has been saved to: " + var3.getAbsolutePath());
 			} else {
 				this.getLogAgent().logSevere("We were unable to save this crash report to disk.");
@@ -364,26 +466,32 @@
 			} finally {
 				this.systemExitNow();
 			}
-
 		}
-
 	}
 
 	protected File getDataDirectory() {
 		return new File(".");
 	}
 
-	protected void finalTick(CrashReport var1) {
-	}
-
-	protected void systemExitNow() {
-	}
-
+	/**
+	 * Called on exit from the main run() loop.
+	 */
+	protected void finalTick(CrashReport par1CrashReport) {}
+
+	/**
+	 * Directly calls System.exit(0), instantly killing the program.
+	 */
+	protected void systemExitNow() {}
+
+	/**
+	 * Main function called by run() every loop.
+	 */
 	public void tick() {
 		long var1 = System.nanoTime();
 		AxisAlignedBB.getAABBPool().cleanPool();
 		++this.tickCounter;
-		if(this.startProfiling) {
+
+		if (this.startProfiling) {
 			this.startProfiling = false;
 			this.theProfiler.profilingEnabled = true;
 			this.theProfiler.clearProfiling();
@@ -391,7 +499,8 @@
 
 		this.theProfiler.startSection("root");
 		this.updateTimeLightAndEntities();
-		if(this.tickCounter % 900 == 0) {
+
+		if (this.tickCounter % 900 == 0) {
 			this.theProfiler.startSection("save");
 			this.serverConfigManager.saveAllPlayerData();
 			this.saveAllWorlds(true);
@@ -410,11 +519,12 @@
 		this.lastReceivedSize = Packet.receivedSize;
 		this.theProfiler.endSection();
 		this.theProfiler.startSection("snooper");
-		if(!this.usageSnooper.isSnooperRunning() && this.tickCounter > 100) {
+
+		if (!this.usageSnooper.isSnooperRunning() && this.tickCounter > 100) {
 			this.usageSnooper.startSnooper();
 		}
 
-		if(this.tickCounter % 6000 == 0) {
+		if (this.tickCounter % 6000 == 0) {
 			this.usageSnooper.addMemoryStatsToSnooper();
 		}
 
@@ -424,25 +534,27 @@
 
 	public void updateTimeLightAndEntities() {
 		this.theProfiler.startSection("levels");
-
 		int var1;
-		for(var1 = 0; var1 < this.worldServers.length; ++var1) {
+
+		for (var1 = 0; var1 < this.worldServers.length; ++var1) {
 			long var2 = System.nanoTime();
-			if(var1 == 0 || this.getAllowNether()) {
+
+			if (var1 == 0 || this.getAllowNether()) {
 				WorldServer var4 = this.worldServers[var1];
 				this.theProfiler.startSection(var4.getWorldInfo().getWorldName());
 				this.theProfiler.startSection("pools");
 				var4.getWorldVec3Pool().clear();
 				this.theProfiler.endSection();
-				if(this.tickCounter % 20 == 0) {
+
+				if (this.tickCounter % 20 == 0) {
 					this.theProfiler.startSection("timeSync");
 					this.serverConfigManager.sendPacketToAllPlayersInDimension(new Packet4UpdateTime(var4.getTotalWorldTime(), var4.getWorldTime(), var4.getGameRules().getGameRuleBooleanValue("doDaylightCycle")), var4.provider.dimensionId);
 					this.theProfiler.endSection();
 				}
 
 				this.theProfiler.startSection("tick");
-
 				CrashReport var6;
+
 				try {
 					var4.tick();
 				} catch (Throwable var8) {
@@ -470,13 +582,13 @@
 		}
 
 		this.theProfiler.endStartSection("connection");
-		this.getNetworkThread().handleNetworkListenThread();
+		this.getNetworkThread().networkTick();
 		this.theProfiler.endStartSection("players");
-		this.serverConfigManager.onTick();
+		this.serverConfigManager.sendPlayerInfoToAllPlayers();
 		this.theProfiler.endStartSection("tickables");
 
-		for(var1 = 0; var1 < this.p.size(); ++var1) {
-			((IUpdatePlayerListBox)this.p.get(var1)).update();
+		for (var1 = 0; var1 < this.tickables.size(); ++var1) {
+			((IUpdatePlayerListBox)this.tickables.get(var1)).update();
 		}
 
 		this.theProfiler.endSection();
@@ -490,104 +602,158 @@
 		(new ThreadMinecraftServer(this, "Server thread")).start();
 	}
 
-	public File getFile(String var1) {
-		return new File(this.getDataDirectory(), var1);
-	}
-
-	public void logInfo(String var1) {
-		this.getLogAgent().logInfo(var1);
-	}
-
-	public void logWarning(String var1) {
-		this.getLogAgent().logWarning(var1);
-	}
-
-	public WorldServer worldServerForDimension(int var1) {
-		return var1 == -1 ? this.worldServers[1] : (var1 == 1 ? this.worldServers[2] : this.worldServers[0]);
-	}
-
+	/**
+	 * Returns a File object from the specified string.
+	 */
+	public File getFile(String par1Str) {
+		return new File(this.getDataDirectory(), par1Str);
+	}
+
+	/**
+	 * Logs the message with a level of INFO.
+	 */
+	public void logInfo(String par1Str) {
+		this.getLogAgent().logInfo(par1Str);
+	}
+
+	/**
+	 * Logs the message with a level of WARN.
+	 */
+	public void logWarning(String par1Str) {
+		this.getLogAgent().logWarning(par1Str);
+	}
+
+	/**
+	 * Gets the worldServer by the given dimension.
+	 */
+	public WorldServer worldServerForDimension(int par1) {
+		return par1 == -1 ? this.worldServers[1] : (par1 == 1 ? this.worldServers[2] : this.worldServers[0]);
+	}
+
+	/**
+	 * Returns the server's hostname.
+	 */
 	public String getHostname() {
-		return this.r;
+		return this.hostname;
 	}
 
+	/**
+	 * Never used, but "getServerPort" is already taken.
+	 */
 	public int getPort() {
 		return this.serverPort;
 	}
 
-	public String getMotd() {
-		return this.C;
+	/**
+	 * Returns the server message of the day
+	 */
+	public String getServerMOTD() {
+		return this.motd;
 	}
 
+	/**
+	 * Returns the server's Minecraft version as string.
+	 */
 	public String getMinecraftVersion() {
 		return "1.6.4";
 	}
 
+	/**
+	 * Returns the number of players currently on the server.
+	 */
 	public int getCurrentPlayerCount() {
 		return this.serverConfigManager.getCurrentPlayerCount();
 	}
 
+	/**
+	 * Returns the maximum number of players allowed on the server.
+	 */
 	public int getMaxPlayers() {
 		return this.serverConfigManager.getMaxPlayers();
 	}
 
+	/**
+	 * Returns an array of the usernames of all the connected players.
+	 */
 	public String[] getAllUsernames() {
 		return this.serverConfigManager.getAllUsernames();
 	}
 
+	/**
+	 * Used by RCon's Query in the form of "MajorServerMod 1.2.3: MyPlugin 1.3; AnotherPlugin 2.1; AndSoForth 1.0".
+	 */
 	public String getPlugins() {
 		return "";
 	}
 
-	public String handleRConCommand(String var1) {
-		RConConsoleSource.instance.resetLog();
-		this.commandManager.executeCommand(RConConsoleSource.instance, var1);
-		return RConConsoleSource.instance.getLogContents();
+	public String executeCommand(String par1Str) {
+		RConConsoleSource.consoleBuffer.resetLog();
+		this.commandManager.executeCommand(RConConsoleSource.consoleBuffer, par1Str);
+		return RConConsoleSource.consoleBuffer.getChatBuffer();
 	}
 
+	/**
+	 * Returns true if debugging is enabled, false otherwise.
+	 */
 	public boolean isDebuggingEnabled() {
 		return false;
 	}
 
-	public void logSevere(String var1) {
-		this.getLogAgent().logSevere(var1);
+	/**
+	 * Logs the error message with a level of SEVERE.
+	 */
+	public void logSevere(String par1Str) {
+		this.getLogAgent().logSevere(par1Str);
 	}
 
-	public void logDebug(String var1) {
-		if(this.isDebuggingEnabled()) {
-			this.getLogAgent().logInfo(var1);
+	/**
+	 * If isDebuggingEnabled(), logs the message with a level of INFO.
+	 */
+	public void logDebug(String par1Str) {
+		if (this.isDebuggingEnabled()) {
+			this.getLogAgent().logInfo(par1Str);
 		}
-
 	}
 
 	public String getServerModName() {
 		return "vanilla";
 	}
 
-	public CrashReport addServerInfoToCrashReport(CrashReport var1) {
-		var1.getCategory().addCrashSectionCallable("Profiler Position", new CallableIsServerModded(this));
-		if(this.worldServers != null && this.worldServers.length > 0 && this.worldServers[0] != null) {
-			var1.getCategory().addCrashSectionCallable("Vec3 Pool Size", new CallableServerProfiler(this));
-		}
-
-		if(this.serverConfigManager != null) {
-			var1.getCategory().addCrashSectionCallable("Player Count", new CallableServerMemoryStats(this));
-		}
-
-		return var1;
+	/**
+	 * Adds the server info, including from theWorldServer, to the crash report.
+	 */
+	public CrashReport addServerInfoToCrashReport(CrashReport par1CrashReport) {
+		par1CrashReport.getCategory().addCrashSectionCallable("Profiler Position", new CallableIsServerModded(this));
+
+		if (this.worldServers != null && this.worldServers.length > 0 && this.worldServers[0] != null) {
+			par1CrashReport.getCategory().addCrashSectionCallable("Vec3 Pool Size", new CallableServerProfiler(this));
+		}
+
+		if (this.serverConfigManager != null) {
+			par1CrashReport.getCategory().addCrashSectionCallable("Player Count", new CallableServerMemoryStats(this));
+		}
+
+		return par1CrashReport;
 	}
 
-	public List getPossibleCompletions(ICommandSender var1, String var2) {
+	/**
+	 * If par2Str begins with /, then it searches for commands, otherwise it returns players.
+	 */
+	public List getPossibleCompletions(ICommandSender par1ICommandSender, String par2Str) {
 		ArrayList var3 = new ArrayList();
-		if(var2.startsWith("/")) {
-			var2 = var2.substring(1);
-			boolean var10 = !var2.contains(" ");
-			List var11 = this.commandManager.getPossibleCommands(var1, var2);
-			if(var11 != null) {
+
+		if (par2Str.startsWith("/")) {
+			par2Str = par2Str.substring(1);
+			boolean var10 = !par2Str.contains(" ");
+			List var11 = this.commandManager.getPossibleCommands(par1ICommandSender, par2Str);
+
+			if (var11 != null) {
 				Iterator var12 = var11.iterator();
 
-				while(var12.hasNext()) {
+				while (var12.hasNext()) {
 					String var13 = (String)var12.next();
-					if(var10) {
+
+					if (var10) {
 						var3.add("/" + var13);
 					} else {
 						var3.add(var13);
@@ -597,14 +763,15 @@
 
 			return var3;
 		} else {
-			String[] var4 = var2.split(" ", -1);
+			String[] var4 = par2Str.split(" ", -1);
 			String var5 = var4[var4.length - 1];
 			String[] var6 = this.serverConfigManager.getAllUsernames();
 			int var7 = var6.length;
 
-			for(int var8 = 0; var8 < var7; ++var8) {
+			for (int var8 = 0; var8 < var7; ++var8) {
 				String var9 = var6[var8];
-				if(CommandBase.doesStringStartWith(var5, var9)) {
+
+				if (CommandBase.doesStringStartWith(var5, var9)) {
 					var3.add(var9);
 				}
 			}
@@ -613,19 +780,28 @@
 		}
 	}
 
+	/**
+	 * Gets mcServer.
+	 */
 	public static MinecraftServer getServer() {
-		return l;
+		return mcServer;
 	}
 
+	/**
+	 * Gets the name of this command sender (usually username, but possibly "Rcon")
+	 */
 	public String getCommandSenderName() {
 		return "Server";
 	}
 
-	public void sendChatToPlayer(ChatMessageComponent var1) {
-		this.getLogAgent().logInfo(var1.toString());
+	public void sendChatToPlayer(ChatMessageComponent par1ChatMessageComponent) {
+		this.getLogAgent().logInfo(par1ChatMessageComponent.toString());
 	}
 
-	public boolean canCommandSenderUseCommand(int var1, String var2) {
+	/**
+	 * Returns true if the command sender is allowed to use the given command.
+	 */
+	public boolean canCommandSenderUseCommand(int par1, String par2Str) {
 		return true;
 	}
 
@@ -633,96 +809,119 @@
 		return this.commandManager;
 	}
 
+	/**
+	 * Gets KeyPair instanced in MinecraftServer.
+	 */
 	public KeyPair getKeyPair() {
-		return this.J;
+		return this.serverKeyPair;
 	}
 
+	/**
+	 * Gets serverPort.
+	 */
 	public int getServerPort() {
 		return this.serverPort;
 	}
 
-	public void setServerPort(int var1) {
-		this.serverPort = var1;
+	public void setServerPort(int par1) {
+		this.serverPort = par1;
 	}
 
+	/**
+	 * Returns the username of the server owner (for integrated servers)
+	 */
 	public String getServerOwner() {
-		return this.K;
+		return this.serverOwner;
 	}
 
-	public void setServerOwner(String var1) {
-		this.K = var1;
+	/**
+	 * Sets the username of the owner of this server (in the case of an integrated server)
+	 */
+	public void setServerOwner(String par1Str) {
+		this.serverOwner = par1Str;
 	}
 
 	public boolean isSinglePlayer() {
-		return this.K != null;
+		return this.serverOwner != null;
 	}
 
 	public String getFolderName() {
-		return this.L;
-	}
-
-	public void setFolderName(String var1) {
-		this.L = var1;
-	}
-
-	public void setWorldName(String var1) {
-		this.M = var1;
+		return this.folderName;
+	}
+
+	public void setFolderName(String par1Str) {
+		this.folderName = par1Str;
+	}
+
+	public void setWorldName(String par1Str) {
+		this.worldName = par1Str;
 	}
 
 	public String getWorldName() {
-		return this.M;
-	}
-
-	public void setKeyPair(KeyPair var1) {
-		this.J = var1;
-	}
-
-	public void setDifficultyForAllWorlds(int var1) {
-		for(int var2 = 0; var2 < this.worldServers.length; ++var2) {
+		return this.worldName;
+	}
+
+	public void setKeyPair(KeyPair par1KeyPair) {
+		this.serverKeyPair = par1KeyPair;
+	}
+
+	public void setDifficultyForAllWorlds(int par1) {
+		for (int var2 = 0; var2 < this.worldServers.length; ++var2) {
 			WorldServer var3 = this.worldServers[var2];
-			if(var3 != null) {
-				if(var3.getWorldInfo().isHardcoreModeEnabled()) {
+
+			if (var3 != null) {
+				if (var3.getWorldInfo().isHardcoreModeEnabled()) {
 					var3.difficultySetting = 3;
 					var3.setAllowedSpawnTypes(true, true);
-				} else if(this.isSinglePlayer()) {
-					var3.difficultySetting = var1;
+				} else if (this.isSinglePlayer()) {
+					var3.difficultySetting = par1;
 					var3.setAllowedSpawnTypes(var3.difficultySetting > 0, true);
 				} else {
-					var3.difficultySetting = var1;
+					var3.difficultySetting = par1;
 					var3.setAllowedSpawnTypes(this.allowSpawnMonsters(), this.canSpawnAnimals);
 				}
 			}
 		}
-
 	}
 
 	protected boolean allowSpawnMonsters() {
 		return true;
 	}
 
+	/**
+	 * Gets whether this is a demo or not.
+	 */
 	public boolean isDemo() {
 		return this.isDemo;
 	}
 
-	public void setDemo(boolean var1) {
-		this.isDemo = var1;
+	/**
+	 * Sets whether this is a demo or not.
+	 */
+	public void setDemo(boolean par1) {
+		this.isDemo = par1;
 	}
 
-	public void canCreateBonusChest(boolean var1) {
-		this.enableBonusChest = var1;
+	public void canCreateBonusChest(boolean par1) {
+		this.enableBonusChest = par1;
 	}
 
 	public ISaveFormat getActiveAnvilConverter() {
 		return this.anvilConverterForAnvilFile;
 	}
 
+	/**
+	 * WARNING : directly calls
+	 * getActiveAnvilConverter().deleteWorldDirectory(theWorldServer[0].getSaveHandler().getWorldDirectoryName());
+	 */
 	public void deleteWorldAndStopServer() {
 		this.worldIsBeingDeleted = true;
 		this.getActiveAnvilConverter().flushCache();
 
-		for(int var1 = 0; var1 < this.worldServers.length; ++var1) {
+		for (int var1 = 0; var1 < this.worldServers.length; ++var1) {
 			WorldServer var2 = this.worldServers[var1];
-			if(var2 != null) {
+
+			if (var2 != null) {
 				var2.flush();
 			}
 		}
@@ -732,59 +931,65 @@
 	}
 
 	public String getTexturePack() {
-		return this.Q;
-	}
-
-	public void setTexturePack(String var1) {
-		this.Q = var1;
-	}
-
-	public void addServerStatsToSnooper(PlayerUsageSnooper var1) {
-		var1.addData("whitelist_enabled", Boolean.valueOf(false));
-		var1.addData("whitelist_count", Integer.valueOf(0));
-		var1.addData("players_current", Integer.valueOf(this.getCurrentPlayerCount()));
-		var1.addData("players_max", Integer.valueOf(this.getMaxPlayers()));
-		var1.addData("players_seen", Integer.valueOf(this.serverConfigManager.getAvailablePlayerDat().length));
-		var1.addData("uses_auth", Boolean.valueOf(this.onlineMode));
-		var1.addData("gui_state", this.getGuiEnabled() ? "enabled" : "disabled");
-		var1.addData("run_time", Long.valueOf((getCurrentTimeMillis() - var1.func_130105_g()) / 60L * 1000L));
-		var1.addData("avg_tick_ms", Integer.valueOf((int)(MathHelper.average(this.tickTimeArray) * 1.0E-6D)));
-		var1.addData("avg_sent_packet_count", Integer.valueOf((int)MathHelper.average(this.sentPacketCountArray)));
-		var1.addData("avg_sent_packet_size", Integer.valueOf((int)MathHelper.average(this.sentPacketSizeArray)));
-		var1.addData("avg_rec_packet_count", Integer.valueOf((int)MathHelper.average(this.receivedPacketCountArray)));
-		var1.addData("avg_rec_packet_size", Integer.valueOf((int)MathHelper.average(this.receivedPacketSizeArray)));
+		return this.texturePack;
+	}
+
+	public void setTexturePack(String par1Str) {
+		this.texturePack = par1Str;
+	}
+
+	public void addServerStatsToSnooper(PlayerUsageSnooper par1PlayerUsageSnooper) {
+		par1PlayerUsageSnooper.addData("whitelist_enabled", Boolean.valueOf(false));
+		par1PlayerUsageSnooper.addData("whitelist_count", Integer.valueOf(0));
+		par1PlayerUsageSnooper.addData("players_current", Integer.valueOf(this.getCurrentPlayerCount()));
+		par1PlayerUsageSnooper.addData("players_max", Integer.valueOf(this.getMaxPlayers()));
+		par1PlayerUsageSnooper.addData("players_seen", Integer.valueOf(this.serverConfigManager.getAvailablePlayerDat().length));
+		par1PlayerUsageSnooper.addData("uses_auth", Boolean.valueOf(this.onlineMode));
+		par1PlayerUsageSnooper.addData("gui_state", this.getGuiEnabled() ? "enabled" : "disabled");
+		par1PlayerUsageSnooper.addData("run_time", Long.valueOf((getSystemTimeMillis() - par1PlayerUsageSnooper.func_130105_g()) / 60L * 1000L));
+		par1PlayerUsageSnooper.addData("avg_tick_ms", Integer.valueOf((int)(MathHelper.average(this.tickTimeArray) * 1.0E-6D)));
+		par1PlayerUsageSnooper.addData("avg_sent_packet_count", Integer.valueOf((int)MathHelper.average(this.sentPacketCountArray)));
+		par1PlayerUsageSnooper.addData("avg_sent_packet_size", Integer.valueOf((int)MathHelper.average(this.sentPacketSizeArray)));
+		par1PlayerUsageSnooper.addData("avg_rec_packet_count", Integer.valueOf((int)MathHelper.average(this.receivedPacketCountArray)));
+		par1PlayerUsageSnooper.addData("avg_rec_packet_size", Integer.valueOf((int)MathHelper.average(this.receivedPacketSizeArray)));
 		int var2 = 0;
 
-		for(int var3 = 0; var3 < this.worldServers.length; ++var3) {
-			if(this.worldServers[var3] != null) {
+		for (int var3 = 0; var3 < this.worldServers.length; ++var3) {
+			if (this.worldServers[var3] != null) {
 				WorldServer var4 = this.worldServers[var3];
 				WorldInfo var5 = var4.getWorldInfo();
-				var1.addData("world[" + var2 + "][dimension]", Integer.valueOf(var4.provider.dimensionId));
-				var1.addData("world[" + var2 + "][mode]", var5.getGameType());
-				var1.addData("world[" + var2 + "][difficulty]", Integer.valueOf(var4.difficultySetting));
-				var1.addData("world[" + var2 + "][hardcore]", Boolean.valueOf(var5.isHardcoreModeEnabled()));
-				var1.addData("world[" + var2 + "][generator_name]", var5.getTerrainType().getWorldTypeName());
-				var1.addData("world[" + var2 + "][generator_version]", Integer.valueOf(var5.getTerrainType().getGeneratorVersion()));
-				var1.addData("world[" + var2 + "][height]", Integer.valueOf(this.buildLimit));
-				var1.addData("world[" + var2 + "][chunks_loaded]", Integer.valueOf(var4.getChunkProvider().getLoadedChunkCount()));
+				par1PlayerUsageSnooper.addData("world[" + var2 + "][dimension]", Integer.valueOf(var4.provider.dimensionId));
+				par1PlayerUsageSnooper.addData("world[" + var2 + "][mode]", var5.getGameType());
+				par1PlayerUsageSnooper.addData("world[" + var2 + "][difficulty]", Integer.valueOf(var4.difficultySetting));
+				par1PlayerUsageSnooper.addData("world[" + var2 + "][hardcore]", Boolean.valueOf(var5.isHardcoreModeEnabled()));
+				par1PlayerUsageSnooper.addData("world[" + var2 + "][generator_name]", var5.getTerrainType().getWorldTypeName());
+				par1PlayerUsageSnooper.addData("world[" + var2 + "][generator_version]", Integer.valueOf(var5.getTerrainType().getGeneratorVersion()));
+				par1PlayerUsageSnooper.addData("world[" + var2 + "][height]", Integer.valueOf(this.buildLimit));
+				par1PlayerUsageSnooper.addData("world[" + var2 + "][chunks_loaded]", Integer.valueOf(var4.getChunkProvider().getLoadedChunkCount()));
 				++var2;
 			}
 		}
 
-		var1.addData("worlds", Integer.valueOf(var2));
-	}
-
-	public void addServerTypeToSnooper(PlayerUsageSnooper var1) {
-		var1.addData("singleplayer", Boolean.valueOf(this.isSinglePlayer()));
-		var1.addData("server_brand", this.getServerModName());
-		var1.addData("gui_supported", GraphicsEnvironment.isHeadless() ? "headless" : "supported");
-		var1.addData("dedicated", Boolean.valueOf(this.isDedicatedServer()));
-	}
-
+		par1PlayerUsageSnooper.addData("worlds", Integer.valueOf(var2));
+	}
+
+	public void addServerTypeToSnooper(PlayerUsageSnooper par1PlayerUsageSnooper) {
+		par1PlayerUsageSnooper.addData("singleplayer", Boolean.valueOf(this.isSinglePlayer()));
+		par1PlayerUsageSnooper.addData("server_brand", this.getServerModName());
+		par1PlayerUsageSnooper.addData("gui_supported", GraphicsEnvironment.isHeadless() ? "headless" : "supported");
+		par1PlayerUsageSnooper.addData("dedicated", Boolean.valueOf(this.isDedicatedServer()));
+	}
+
+	/**
+	 * Returns whether snooping is enabled or not.
+	 */
 	public boolean isSnooperEnabled() {
 		return true;
 	}
 
+	/**
+	 * This is checked to be 16 upon receiving the packet, otherwise the packet is ignored.
+	 */
 	public int textureSize() {
 		return 16;
 	}
@@ -795,58 +1000,61 @@
 		return this.onlineMode;
 	}
 
-	public void setOnlineMode(boolean var1) {
-		this.onlineMode = var1;
+	public void setOnlineMode(boolean par1) {
+		this.onlineMode = par1;
 	}
 
 	public boolean getCanSpawnAnimals() {
 		return this.canSpawnAnimals;
 	}
 
-	public void setCanSpawnAnimals(boolean var1) {
-		this.canSpawnAnimals = var1;
+	public void setCanSpawnAnimals(boolean par1) {
+		this.canSpawnAnimals = par1;
 	}
 
 	public boolean getCanSpawnNPCs() {
 		return this.canSpawnNPCs;
 	}
 
-	public void setCanSpawnNPCs(boolean var1) {
-		this.canSpawnNPCs = var1;
+	public void setCanSpawnNPCs(boolean par1) {
+		this.canSpawnNPCs = par1;
 	}
 
 	public boolean isPVPEnabled() {
 		return this.pvpEnabled;
 	}
 
-	public void setAllowPvp(boolean var1) {
-		this.pvpEnabled = var1;
+	public void setAllowPvp(boolean par1) {
+		this.pvpEnabled = par1;
 	}
 
 	public boolean isFlightAllowed() {
 		return this.allowFlight;
 	}
 
-	public void setAllowFlight(boolean var1) {
-		this.allowFlight = var1;
+	public void setAllowFlight(boolean par1) {
+		this.allowFlight = par1;
 	}
 
+	/**
+	 * Return whether command blocks are enabled.
+	 */
 	public abstract boolean isCommandBlockEnabled();
 
 	public String getMOTD() {
-		return this.C;
+		return this.motd;
 	}
 
-	public void setMOTD(String var1) {
-		this.C = var1;
+	public void setMOTD(String par1Str) {
+		this.motd = par1Str;
 	}
 
 	public int getBuildLimit() {
 		return this.buildLimit;
 	}
 
-	public void setBuildLimit(int var1) {
-		this.buildLimit = var1;
+	public void setBuildLimit(int par1) {
+		this.buildLimit = par1;
 	}
 
 	public boolean isServerStopped() {
@@ -857,15 +1065,17 @@
 		return this.serverConfigManager;
 	}
 
-	public void setConfigurationManager(ServerConfigurationManager var1) {
-		this.serverConfigManager = var1;
+	public void setConfigurationManager(ServerConfigurationManager par1ServerConfigurationManager) {
+		this.serverConfigManager = par1ServerConfigurationManager;
 	}
 
-	public void setGameType(EnumGameType var1) {
-		for(int var2 = 0; var2 < this.worldServers.length; ++var2) {
-			getServer().worldServers[var2].getWorldInfo().setGameType(var1);
+	/**
+	 * Sets the game type for all worlds.
+	 */
+	public void setGameType(EnumGameType par1EnumGameType) {
+		for (int var2 = 0; var2 < this.worldServers.length; ++var2) {
+			getServer().worldServers[var2].getWorldInfo().setGameType(par1EnumGameType);
 		}
-
 	}
 
 	public abstract NetworkListenThread getNetworkThread();
@@ -878,6 +1088,9 @@
 		return false;
 	}
 
+	/**
+	 * On dedicated does nothing. On integrated, sets commandsAllowedForAll, gameType and allows external connections.
+	 */
 	public abstract String shareToLAN(EnumGameType var1, boolean var2);
 
 	public int getTickCounter() {
@@ -892,7 +1105,10 @@
 		return this.usageSnooper;
 	}
 
-	public ChunkCoordinates getCommandSenderPosition() {
+	/**
+	 * Return the position for this command sender.
+	 */
+	public ChunkCoordinates getPlayerCoordinates() {
 		return new ChunkCoordinates(0, 0, 0);
 	}
 
@@ -900,18 +1116,24 @@
 		return this.worldServers[0];
 	}
 
+	/**
+	 * Return the spawn protection area's size.
+	 */
 	public int getSpawnProtectionSize() {
 		return 16;
 	}
 
-	public boolean isBlockProtected(World var1, int var2, int var3, int var4, EntityPlayer var5) {
+	/**
+	 * Returns true if a player does not have permission to edit the block at the given coordinates.
+	 */
+	public boolean isBlockProtected(World par1World, int par2, int par3, int par4, EntityPlayer par5EntityPlayer) {
 		return false;
 	}
 
 	public abstract ILogAgent getLogAgent();
 
-	public void setForceGamemode(boolean var1) {
-		this.isGamemodeForced = var1;
+	public void setForceGamemode(boolean par1) {
+		this.isGamemodeForced = par1;
 	}
 
 	public boolean getForceGamemode() {
@@ -919,10 +1141,13 @@
 	}
 
 	public Proxy getServerProxy() {
-		return this.c;
+		return this.serverProxy;
 	}
 
-	public static long getCurrentTimeMillis() {
+	/**
+	 * returns the difference, measured in milliseconds, between the current system time and midnight, January 1, 1970 UTC.
+	 */
+	public static long getSystemTimeMillis() {
 		return System.currentTimeMillis();
 	}
 
@@ -930,11 +1155,14 @@
 		return this.field_143008_E;
 	}
 
-	public void func_143006_e(int var1) {
-		this.field_143008_E = var1;
+	public void func_143006_e(int par1) {
+		this.field_143008_E = par1;
 	}
 
-	public static ServerConfigurationManager getServerConfigurationManager(MinecraftServer var0) {
-		return var0.serverConfigManager;
+	/**
+	 * Gets the current player count, maximum player count, and player entity list.
+	 */
+	public static ServerConfigurationManager getServerConfigurationManager(MinecraftServer par0MinecraftServer) {
+		return par0MinecraftServer.serverConfigManager;
 	}
 }
